<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<!--BEGIN PROJECT_NAME--><title>Opus: Opus: Opus Multistream API</title><!--END PROJECT_NAME-->
<!--BEGIN !PROJECT_NAME--><title>Opus: Opus Multistream API</title><!--END !PROJECT_NAME-->
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="customdoxygen.css" rel="stylesheet" type="text/css" />
$treeview
$search
$mathjax
</head>
<body>
<div id="top"><!-- do not remove this div! -->

<!--BEGIN TITLEAREA-->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 64px;">
  <!--BEGIN PROJECT_LOGO-->
  <td id="projectlogo"><img alt="Logo" src="$projectlogo"/></td>
  <!--END PROJECT_LOGO-->
  <!--BEGIN PROJECT_NAME-->
  <td style="padding-left: 0.5em;">
  <div id="projectname"><img src="opus_logo.svg" width=112 height=64 alt="Opus"/><!--Opus--></div>
  </td>
  <td><table style="padding-left: 0.5em;" cellspacing="0" cellpadding="0"><tbody>
   <tr><td>
   <!--BEGIN PROJECT_BRIEF--><div id="projectbrief">$projectbrief</div><!--END PROJECT_BRIEF-->
   </td></tr>
  <td><!--BEGIN PROJECT_NUMBER--><span id="projectnumber">1.0.2</span><!--END PROJECT_NUMBER-->
   </td></tr>
   </table>
  </td>
  <!--END PROJECT_NAME-->
  <!--BEGIN !PROJECT_NAME-->
   <!--BEGIN PROJECT_BRIEF-->
    <td style="padding-left: 0.5em;">
    <div id="projectbrief">$projectbrief</div>
    </td>
   <!--END PROJECT_BRIEF-->
  <!--END !PROJECT_NAME-->
  <!--BEGIN DISABLE_INDEX-->
   <!--BEGIN SEARCHENGINE-->
   <td>$searchbox</td>
   <!--END SEARCHENGINE-->
  <!--END DISABLE_INDEX-->
 </tr>
 </tbody>
</table>
</div>
<!--END TITLEAREA-->
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Opus Multistream API</h1>
<p>The multistream API allows individual Opus streams to be combined into a single packet, enabling support for up to 255 channels.  
<a href="#_details">More...</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="group__opus__multistream.html#gae5826674d142fc873ebc1d781c507dd7">OpusMSEncoder</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__opus__multistream.html#gae5826674d142fc873ebc1d781c507dd7">OpusMSEncoder</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Opus multistream encoder state.  <a href="#gae5826674d142fc873ebc1d781c507dd7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="group__opus__multistream.html#gad3497495deb9a8ace82e76cd4f93e0e4">OpusMSDecoder</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__opus__multistream.html#gad3497495deb9a8ace82e76cd4f93e0e4">OpusMSDecoder</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Opus multistream decoder state.  <a href="#gad3497495deb9a8ace82e76cd4f93e0e4"></a><br/></td></tr>
<tr><td colspan="2"><h2>Multistream encoder functions</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrp3d1c363464c5de793a99376ffb2fb267"></a> </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="opus__types_8h.html#aa4d309d6f80b99dbabebc8f98879ab9a">opus_int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__opus__multistream.html#ga8642aa9cf16115229a655574d832293b">opus_multistream_encoder_get_size</a> (int streams, int coupled_streams)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the size of an OpusMSEncoder structure.  <a href="#ga8642aa9cf16115229a655574d832293b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__opus__multistream.html#gae5826674d142fc873ebc1d781c507dd7">OpusMSEncoder</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__opus__multistream.html#gaeb64c648ed8155f824ca8d9a93ccecae">opus_multistream_encoder_create</a> (<a class="el" href="opus__types_8h.html#aa4d309d6f80b99dbabebc8f98879ab9a">opus_int32</a> Fs, int channels, int streams, int coupled_streams, const unsigned char *mapping, int application, int *error)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocates and initializes a multistream encoder state.  <a href="#gaeb64c648ed8155f824ca8d9a93ccecae"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__opus__multistream.html#gae7586aa54c322fd9599de24b5c8b8c01">opus_multistream_encoder_init</a> (<a class="el" href="group__opus__multistream.html#gae5826674d142fc873ebc1d781c507dd7">OpusMSEncoder</a> *st, <a class="el" href="opus__types_8h.html#aa4d309d6f80b99dbabebc8f98879ab9a">opus_int32</a> Fs, int channels, int streams, int coupled_streams, const unsigned char *mapping, int application)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize a previously allocated multistream encoder state.  <a href="#gae7586aa54c322fd9599de24b5c8b8c01"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__opus__multistream.html#ga9e1000f220d9872e9f3b6e4f2417b445">opus_multistream_encode</a> (<a class="el" href="group__opus__multistream.html#gae5826674d142fc873ebc1d781c507dd7">OpusMSEncoder</a> *st, const <a class="el" href="opus__types_8h.html#acc9ed7cf60479eb81f9648c6ec27dc26">opus_int16</a> *pcm, int frame_size, unsigned char *data, <a class="el" href="opus__types_8h.html#aa4d309d6f80b99dbabebc8f98879ab9a">opus_int32</a> max_data_bytes)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Encodes a multistream Opus frame.  <a href="#ga9e1000f220d9872e9f3b6e4f2417b445"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__opus__multistream.html#gaff832211e572536941b9d6094f9f42ce">opus_multistream_encode_float</a> (<a class="el" href="group__opus__multistream.html#gae5826674d142fc873ebc1d781c507dd7">OpusMSEncoder</a> *st, const float *pcm, int frame_size, unsigned char *data, <a class="el" href="opus__types_8h.html#aa4d309d6f80b99dbabebc8f98879ab9a">opus_int32</a> max_data_bytes)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Encodes a multistream Opus frame from floating point input.  <a href="#gaff832211e572536941b9d6094f9f42ce"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__opus__multistream.html#gaec819b8d4b38350aba6959cee7d33f94">opus_multistream_encoder_destroy</a> (<a class="el" href="group__opus__multistream.html#gae5826674d142fc873ebc1d781c507dd7">OpusMSEncoder</a> *st)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Frees an <code>OpusMSEncoder</code> allocated by <a class="el" href="group__opus__multistream.html#gaeb64c648ed8155f824ca8d9a93ccecae" title="Allocates and initializes a multistream encoder state.">opus_multistream_encoder_create()</a>.  <a href="#gaec819b8d4b38350aba6959cee7d33f94"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__opus__multistream.html#gae14328330c548dede66c494f51e33707">opus_multistream_encoder_ctl</a> (<a class="el" href="group__opus__multistream.html#gae5826674d142fc873ebc1d781c507dd7">OpusMSEncoder</a> *st, int request,...)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Perform a CTL function on a multistream Opus encoder.  <a href="#gae14328330c548dede66c494f51e33707"></a><br/></td></tr>
<tr><td colspan="2"><h2>Multistream decoder functions</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrpcc7358059c41f41af9a3b9b2f9644064"></a> </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="opus__types_8h.html#aa4d309d6f80b99dbabebc8f98879ab9a">opus_int32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__opus__multistream.html#ga38d745963e7903890c80278bc2569c39">opus_multistream_decoder_get_size</a> (int streams, int coupled_streams)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the size of an <code>OpusMSDecoder</code> structure.  <a href="#ga38d745963e7903890c80278bc2569c39"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__opus__multistream.html#gad3497495deb9a8ace82e76cd4f93e0e4">OpusMSDecoder</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__opus__multistream.html#ga3c0e342774174c471e61cedba53755c9">opus_multistream_decoder_create</a> (<a class="el" href="opus__types_8h.html#aa4d309d6f80b99dbabebc8f98879ab9a">opus_int32</a> Fs, int channels, int streams, int coupled_streams, const unsigned char *mapping, int *error)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocates and initializes a multistream decoder state.  <a href="#ga3c0e342774174c471e61cedba53755c9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__opus__multistream.html#ga09a4d14fc497d4f6fbe76bd1c5d45436">opus_multistream_decoder_init</a> (<a class="el" href="group__opus__multistream.html#gad3497495deb9a8ace82e76cd4f93e0e4">OpusMSDecoder</a> *st, <a class="el" href="opus__types_8h.html#aa4d309d6f80b99dbabebc8f98879ab9a">opus_int32</a> Fs, int channels, int streams, int coupled_streams, const unsigned char *mapping)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Intialize a previously allocated decoder state object.  <a href="#ga09a4d14fc497d4f6fbe76bd1c5d45436"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__opus__multistream.html#gaa4b89541efe01970cf52e4a336db3ad0">opus_multistream_decode</a> (<a class="el" href="group__opus__multistream.html#gad3497495deb9a8ace82e76cd4f93e0e4">OpusMSDecoder</a> *st, const unsigned char *data, <a class="el" href="opus__types_8h.html#aa4d309d6f80b99dbabebc8f98879ab9a">opus_int32</a> len, <a class="el" href="opus__types_8h.html#acc9ed7cf60479eb81f9648c6ec27dc26">opus_int16</a> *pcm, int frame_size, int decode_fec)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Decode a multistream Opus packet.  <a href="#gaa4b89541efe01970cf52e4a336db3ad0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__opus__multistream.html#ga620e67c67872f8ea0b67a200c729630a">opus_multistream_decode_float</a> (<a class="el" href="group__opus__multistream.html#gad3497495deb9a8ace82e76cd4f93e0e4">OpusMSDecoder</a> *st, const unsigned char *data, <a class="el" href="opus__types_8h.html#aa4d309d6f80b99dbabebc8f98879ab9a">opus_int32</a> len, float *pcm, int frame_size, int decode_fec)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Decode a multistream Opus packet with floating point output.  <a href="#ga620e67c67872f8ea0b67a200c729630a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__opus__multistream.html#ga4b3dca8d46e5868cc133f3f6d2b57688">opus_multistream_decoder_ctl</a> (<a class="el" href="group__opus__multistream.html#gad3497495deb9a8ace82e76cd4f93e0e4">OpusMSDecoder</a> *st, int request,...)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Perform a CTL function on a multistream Opus decoder.  <a href="#ga4b3dca8d46e5868cc133f3f6d2b57688"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__opus__multistream.html#gaaec72b484eabc78d7869221c6d2ce080">opus_multistream_decoder_destroy</a> (<a class="el" href="group__opus__multistream.html#gad3497495deb9a8ace82e76cd4f93e0e4">OpusMSDecoder</a> *st)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Frees an <code>OpusMSDecoder</code> allocated by <a class="el" href="group__opus__multistream.html#ga3c0e342774174c471e61cedba53755c9" title="Allocates and initializes a multistream decoder state.">opus_multistream_decoder_create()</a>.  <a href="#gaaec72b484eabc78d7869221c6d2ce080"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>The multistream API allows individual Opus streams to be combined into a single packet, enabling support for up to 255 channels. </p>
<p>Unlike an elementary Opus stream, the encoder and decoder must negotiate the channel configuration before the decoder can successfully interpret the data in the packets produced by the encoder. Some basic information, such as packet duration, can be computed without any special negotiation.</p>
<p>The format for multistream Opus packets is defined in the <a href="http://tools.ietf.org/html/draft-terriberry-oggopus">Ogg encapsulation specification</a> and is based on the self-delimited Opus framing described in Appendix B of <a href="http://tools.ietf.org/html/rfc6716">RFC 6716</a>. Normal Opus packets are just a degenerate case of multistream Opus packets, and can be encoded or decoded with the multistream API by setting <code>streams</code> to <code>1</code> when initializing the encoder or decoder.</p>
<p>Multistream Opus streams can contain up to 255 elementary Opus streams. These may be either "uncoupled" or "coupled", indicating that the decoder is configured to decode them to either 1 or 2 channels, respectively. The streams are ordered so that all coupled streams appear at the beginning.</p>
<p>A <code>mapping</code> table defines which decoded channel <code>i</code> should be used for each input/output (I/O) channel <code>j</code>. This table is typically provided as an unsigned char array. Let <code>i = mapping[j]</code> be the index for I/O channel <code>j</code>. If <code>i &lt; 2*coupled_streams</code>, then I/O channel <code>j</code> is encoded as the left channel of stream <code>(i/2)</code> if <code>i</code> is even, or as the right channel of stream <code>(i/2)</code> if <code>i</code> is odd. Otherwise, I/O channel <code>j</code> is encoded as mono in stream <code>(i - coupled_streams)</code>, unless it has the special value 255, in which case it is omitted from the encoding entirely (the decoder will reproduce it as silence). Each value <code>i</code> must either be the special value 255 or be less than <code>streams + coupled_streams</code>.</p>
<p>The output channels specified by the encoder should use the <a href="http://www.xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-800004.3.9">Vorbis channel ordering</a>. A decoder may wish to apply an additional permutation to the mapping the encoder used to achieve a different output channel order (e.g. for outputing in WAV order).</p>
<p>Each multistream packet contains an Opus packet for each stream, and all of the Opus packets in a single multistream packet must have the same duration. Therefore the duration of a multistream packet can be extracted from the TOC sequence of the first stream, which is located at the beginning of the packet, just like an elementary Opus stream:</p>
<div class="fragment"><pre class="fragment"> <span class="keywordtype">int</span> nb_samples;
 <span class="keywordtype">int</span> nb_frames;
 nb_frames = <a class="code" href="group__opus__decoder.html#ga064cb2ed9e77a934cd7db6c13b02c584" title="Gets the number of frames in an Opus packet.">opus_packet_get_nb_frames</a>(data, len);
 <span class="keywordflow">if</span> (nb_frames &lt; 1)
   <span class="keywordflow">return</span> nb_frames;
 nb_samples = <a class="code" href="group__opus__decoder.html#gab2a955acced631c6cb7876bbdc7953d4" title="Gets the number of samples per frame from an Opus packet.">opus_packet_get_samples_per_frame</a>(data, 48000) * nb_frames;
</pre></div><p>The general encoding and decoding process proceeds exactly the same as in the normal <a class="el" href="group__opus__encoder.html">Opus Encoder</a> and <a class="el" href="group__opus__decoder.html">Opus Decoder</a> APIs. See their documentation for an overview of how to use the corresponding multistream functions. </p>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="gad3497495deb9a8ace82e76cd4f93e0e4"></a><!-- doxytag: member="opus_multistream.h::OpusMSDecoder" ref="gad3497495deb9a8ace82e76cd4f93e0e4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="group__opus__multistream.html#gad3497495deb9a8ace82e76cd4f93e0e4">OpusMSDecoder</a> <a class="el" href="group__opus__multistream.html#gad3497495deb9a8ace82e76cd4f93e0e4">OpusMSDecoder</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Opus multistream decoder state. </p>
<p>This contains the complete state of a multistream Opus decoder. It is position independent and can be freely copied. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__opus__multistream.html#ga3c0e342774174c471e61cedba53755c9" title="Allocates and initializes a multistream decoder state.">opus_multistream_decoder_create</a> </dd>
<dd>
<a class="el" href="group__opus__multistream.html#ga09a4d14fc497d4f6fbe76bd1c5d45436" title="Intialize a previously allocated decoder state object.">opus_multistream_decoder_init</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gae5826674d142fc873ebc1d781c507dd7"></a><!-- doxytag: member="opus_multistream.h::OpusMSEncoder" ref="gae5826674d142fc873ebc1d781c507dd7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="group__opus__multistream.html#gae5826674d142fc873ebc1d781c507dd7">OpusMSEncoder</a> <a class="el" href="group__opus__multistream.html#gae5826674d142fc873ebc1d781c507dd7">OpusMSEncoder</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Opus multistream encoder state. </p>
<p>This contains the complete state of a multistream Opus encoder. It is position independent and can be freely copied. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__opus__multistream.html#gaeb64c648ed8155f824ca8d9a93ccecae" title="Allocates and initializes a multistream encoder state.">opus_multistream_encoder_create</a> </dd>
<dd>
<a class="el" href="group__opus__multistream.html#gae7586aa54c322fd9599de24b5c8b8c01" title="Initialize a previously allocated multistream encoder state.">opus_multistream_encoder_init</a> </dd></dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gaa4b89541efe01970cf52e4a336db3ad0"></a><!-- doxytag: member="opus_multistream.h::opus_multistream_decode" ref="gaa4b89541efe01970cf52e4a336db3ad0" args="(OpusMSDecoder *st, const unsigned char *data, opus_int32 len, opus_int16 *pcm, int frame_size, int decode_fec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int opus_multistream_decode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__opus__multistream.html#gad3497495deb9a8ace82e76cd4f93e0e4">OpusMSDecoder</a> *&nbsp;</td>
          <td class="paramname"> <em>st</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="opus__types_8h.html#aa4d309d6f80b99dbabebc8f98879ab9a">opus_int32</a>&nbsp;</td>
          <td class="paramname"> <em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="opus__types_8h.html#acc9ed7cf60479eb81f9648c6ec27dc26">opus_int16</a> *&nbsp;</td>
          <td class="paramname"> <em>pcm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>frame_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>decode_fec</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Decode a multistream Opus packet. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>st</em>&nbsp;</td><td><code>OpusMSDecoder*</code>: Multistream decoder state. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>data</em>&nbsp;</td><td><code>const unsigned char*</code>: Input payload. Use a <code>NULL</code> pointer to indicate packet loss. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td><code>opus_int32</code>: Number of bytes in payload. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>pcm</em>&nbsp;</td><td><code>opus_int16*</code>: Output signal, with interleaved samples. This must contain room for <code>frame_size*channels</code> samples. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>frame_size</em>&nbsp;</td><td><code>int</code>: The number of samples per channel of available space in <em>pcm</em>. If this is less than the maximum packet duration (120 ms; 5760 for 48kHz), this function will not be capable of decoding some packets. In the case of PLC (data==NULL) or FEC (decode_fec=1), then frame_size needs to be exactly the duration of audio that is missing, otherwise the decoder will not be in the optimal state to decode the next incoming packet. For the PLC and FEC cases, frame_size <b>must</b> be a multiple of 2.5 ms. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>decode_fec</em>&nbsp;</td><td><code>int</code>: Flag (0 or 1) to request that any in-band forward error correction data be decoded. If no such data is available, the frame is decoded as if it were lost. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Number of samples decoded on success or a negative error code (see <a class="el" href="group__opus__errorcodes.html">Error codes</a>) on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="ga620e67c67872f8ea0b67a200c729630a"></a><!-- doxytag: member="opus_multistream.h::opus_multistream_decode_float" ref="ga620e67c67872f8ea0b67a200c729630a" args="(OpusMSDecoder *st, const unsigned char *data, opus_int32 len, float *pcm, int frame_size, int decode_fec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int opus_multistream_decode_float </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__opus__multistream.html#gad3497495deb9a8ace82e76cd4f93e0e4">OpusMSDecoder</a> *&nbsp;</td>
          <td class="paramname"> <em>st</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="opus__types_8h.html#aa4d309d6f80b99dbabebc8f98879ab9a">opus_int32</a>&nbsp;</td>
          <td class="paramname"> <em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>pcm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>frame_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>decode_fec</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Decode a multistream Opus packet with floating point output. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>st</em>&nbsp;</td><td><code>OpusMSDecoder*</code>: Multistream decoder state. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>data</em>&nbsp;</td><td><code>const unsigned char*</code>: Input payload. Use a <code>NULL</code> pointer to indicate packet loss. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td><code>opus_int32</code>: Number of bytes in payload. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>pcm</em>&nbsp;</td><td><code>opus_int16*</code>: Output signal, with interleaved samples. This must contain room for <code>frame_size*channels</code> samples. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>frame_size</em>&nbsp;</td><td><code>int</code>: The number of samples per channel of available space in <em>pcm</em>. If this is less than the maximum packet duration (120 ms; 5760 for 48kHz), this function will not be capable of decoding some packets. In the case of PLC (data==NULL) or FEC (decode_fec=1), then frame_size needs to be exactly the duration of audio that is missing, otherwise the decoder will not be in the optimal state to decode the next incoming packet. For the PLC and FEC cases, frame_size <b>must</b> be a multiple of 2.5 ms. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>decode_fec</em>&nbsp;</td><td><code>int</code>: Flag (0 or 1) to request that any in-band forward error correction data be decoded. If no such data is available, the frame is decoded as if it were lost. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Number of samples decoded on success or a negative error code (see <a class="el" href="group__opus__errorcodes.html">Error codes</a>) on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3c0e342774174c471e61cedba53755c9"></a><!-- doxytag: member="opus_multistream.h::opus_multistream_decoder_create" ref="ga3c0e342774174c471e61cedba53755c9" args="(opus_int32 Fs, int channels, int streams, int coupled_streams, const unsigned char *mapping, int *error)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__opus__multistream.html#gad3497495deb9a8ace82e76cd4f93e0e4">OpusMSDecoder</a>* opus_multistream_decoder_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="opus__types_8h.html#aa4d309d6f80b99dbabebc8f98879ab9a">opus_int32</a>&nbsp;</td>
          <td class="paramname"> <em>Fs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>channels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>streams</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>coupled_streams</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&nbsp;</td>
          <td class="paramname"> <em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>error</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocates and initializes a multistream decoder state. </p>
<p>Call <a class="el" href="group__opus__multistream.html#gaaec72b484eabc78d7869221c6d2ce080" title="Frees an OpusMSDecoder allocated by opus_multistream_decoder_create().">opus_multistream_decoder_destroy()</a> to release this object when finished. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Fs</em>&nbsp;</td><td><code>opus_int32</code>: Sampling rate to decode at (in Hz). This must be one of 8000, 12000, 16000, 24000, or 48000. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>channels</em>&nbsp;</td><td><code>int</code>: Number of channels to output. This must be at most 255. It may be different from the number of coded channels (<code>streams + coupled_streams</code>). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>streams</em>&nbsp;</td><td><code>int</code>: The total number of streams coded in the input. This must be no more than 255. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>coupled_streams</em>&nbsp;</td><td><code>int</code>: Number of streams to decode as coupled (2 channel) streams. This must be no larger than the total number of streams. Additionally, The total number of coded channels (<code>streams + coupled_streams</code>) must be no more than 255. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>mapping</em>&nbsp;</td><td><code>const unsigned char[channels]</code>: Mapping from coded channels to output channels, as described in <a class="el" href="group__opus__multistream.html">Opus Multistream API</a>. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>error</em>&nbsp;</td><td><code>int *</code>: Returns <a class="el" href="group__opus__errorcodes.html#gaa44cf8a185e1b5cb940ef63eb4f02d21" title="No error.">OPUS_OK</a> on success, or an error code (see <a class="el" href="group__opus__errorcodes.html">Error codes</a>) on failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4b3dca8d46e5868cc133f3f6d2b57688"></a><!-- doxytag: member="opus_multistream.h::opus_multistream_decoder_ctl" ref="ga4b3dca8d46e5868cc133f3f6d2b57688" args="(OpusMSDecoder *st, int request,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int opus_multistream_decoder_ctl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__opus__multistream.html#gad3497495deb9a8ace82e76cd4f93e0e4">OpusMSDecoder</a> *&nbsp;</td>
          <td class="paramname"> <em>st</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Perform a CTL function on a multistream Opus decoder. </p>
<p>Generally the request and subsequent arguments are generated by a convenience macro. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>st</em>&nbsp;</td><td><code>OpusMSDecoder*</code>: Multistream decoder state. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>request</em>&nbsp;</td><td>This and all remaining parameters should be replaced by one of the convenience macros in <a class="el" href="group__opus__genericctls.html">Generic CTLs</a>, <a class="el" href="group__opus__decoderctls.html">Decoder related CTLs</a>, or <a class="el" href="group__opus__multistream__ctls.html">Multistream specific encoder and decoder CTLs</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__opus__genericctls.html" title="These macros are used with the opus_decoder_ctl and opus_encoder_ctl calls to generate...">Generic CTLs</a> </dd>
<dd>
<a class="el" href="group__opus__decoderctls.html">Decoder related CTLs</a> </dd>
<dd>
<a class="el" href="group__opus__multistream__ctls.html" title="These are convenience macros that are specific to the opus_multistream_encoder_ctl()...">Multistream specific encoder and decoder CTLs</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaaec72b484eabc78d7869221c6d2ce080"></a><!-- doxytag: member="opus_multistream.h::opus_multistream_decoder_destroy" ref="gaaec72b484eabc78d7869221c6d2ce080" args="(OpusMSDecoder *st)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void opus_multistream_decoder_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__opus__multistream.html#gad3497495deb9a8ace82e76cd4f93e0e4">OpusMSDecoder</a> *&nbsp;</td>
          <td class="paramname"> <em>st</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Frees an <code>OpusMSDecoder</code> allocated by <a class="el" href="group__opus__multistream.html#ga3c0e342774174c471e61cedba53755c9" title="Allocates and initializes a multistream decoder state.">opus_multistream_decoder_create()</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>st</em>&nbsp;</td><td><code>OpusMSDecoder</code>: Multistream decoder state to be freed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga38d745963e7903890c80278bc2569c39"></a><!-- doxytag: member="opus_multistream.h::opus_multistream_decoder_get_size" ref="ga38d745963e7903890c80278bc2569c39" args="(int streams, int coupled_streams)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="opus__types_8h.html#aa4d309d6f80b99dbabebc8f98879ab9a">opus_int32</a> opus_multistream_decoder_get_size </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>streams</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>coupled_streams</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the size of an <code>OpusMSDecoder</code> structure. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>streams</em>&nbsp;</td><td><code>int</code>: The total number of streams coded in the input. This must be no more than 255. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>coupled_streams</em>&nbsp;</td><td><code>int</code>: Number streams to decode as coupled (2 channel) streams. This must be no larger than the total number of streams. Additionally, The total number of coded channels (<code>streams + coupled_streams</code>) must be no more than 255. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The size in bytes on success, or a negative error code (see <a class="el" href="group__opus__errorcodes.html">Error codes</a>) on error. </dd></dl>

</div>
</div>
<a class="anchor" id="ga09a4d14fc497d4f6fbe76bd1c5d45436"></a><!-- doxytag: member="opus_multistream.h::opus_multistream_decoder_init" ref="ga09a4d14fc497d4f6fbe76bd1c5d45436" args="(OpusMSDecoder *st, opus_int32 Fs, int channels, int streams, int coupled_streams, const unsigned char *mapping)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int opus_multistream_decoder_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__opus__multistream.html#gad3497495deb9a8ace82e76cd4f93e0e4">OpusMSDecoder</a> *&nbsp;</td>
          <td class="paramname"> <em>st</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="opus__types_8h.html#aa4d309d6f80b99dbabebc8f98879ab9a">opus_int32</a>&nbsp;</td>
          <td class="paramname"> <em>Fs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>channels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>streams</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>coupled_streams</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&nbsp;</td>
          <td class="paramname"> <em>mapping</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Intialize a previously allocated decoder state object. </p>
<p>The memory pointed to by <em>st</em> must be at least the size returned by <a class="el" href="group__opus__multistream.html#ga8642aa9cf16115229a655574d832293b" title="Gets the size of an OpusMSEncoder structure.">opus_multistream_encoder_get_size()</a>. This is intended for applications which use their own allocator instead of malloc. To reset a previously initialized state, use the <a class="el" href="group__opus__genericctls.html#gadc74e4fa8bcdf9994187d52d92207337" title="Resets the codec state to be equivalent to a freshly initialized state.">OPUS_RESET_STATE</a> CTL. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__opus__multistream.html#ga3c0e342774174c471e61cedba53755c9" title="Allocates and initializes a multistream decoder state.">opus_multistream_decoder_create</a> </dd>
<dd>
opus_multistream_deocder_get_size </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>st</em>&nbsp;</td><td><code>OpusMSEncoder*</code>: Multistream encoder state to initialize. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Fs</em>&nbsp;</td><td><code>opus_int32</code>: Sampling rate to decode at (in Hz). This must be one of 8000, 12000, 16000, 24000, or 48000. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>channels</em>&nbsp;</td><td><code>int</code>: Number of channels to output. This must be at most 255. It may be different from the number of coded channels (<code>streams + coupled_streams</code>). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>streams</em>&nbsp;</td><td><code>int</code>: The total number of streams coded in the input. This must be no more than 255. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>coupled_streams</em>&nbsp;</td><td><code>int</code>: Number of streams to decode as coupled (2 channel) streams. This must be no larger than the total number of streams. Additionally, The total number of coded channels (<code>streams + coupled_streams</code>) must be no more than 255. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>mapping</em>&nbsp;</td><td><code>const unsigned char[channels]</code>: Mapping from coded channels to output channels, as described in <a class="el" href="group__opus__multistream.html">Opus Multistream API</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="group__opus__errorcodes.html#gaa44cf8a185e1b5cb940ef63eb4f02d21" title="No error.">OPUS_OK</a> on success, or an error code (see <a class="el" href="group__opus__errorcodes.html">Error codes</a>) on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9e1000f220d9872e9f3b6e4f2417b445"></a><!-- doxytag: member="opus_multistream.h::opus_multistream_encode" ref="ga9e1000f220d9872e9f3b6e4f2417b445" args="(OpusMSEncoder *st, const opus_int16 *pcm, int frame_size, unsigned char *data, opus_int32 max_data_bytes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int opus_multistream_encode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__opus__multistream.html#gae5826674d142fc873ebc1d781c507dd7">OpusMSEncoder</a> *&nbsp;</td>
          <td class="paramname"> <em>st</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="opus__types_8h.html#acc9ed7cf60479eb81f9648c6ec27dc26">opus_int16</a> *&nbsp;</td>
          <td class="paramname"> <em>pcm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>frame_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="opus__types_8h.html#aa4d309d6f80b99dbabebc8f98879ab9a">opus_int32</a>&nbsp;</td>
          <td class="paramname"> <em>max_data_bytes</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Encodes a multistream Opus frame. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>st</em>&nbsp;</td><td><code>OpusMSEncoder*</code>: Multistream encoder state. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pcm</em>&nbsp;</td><td><code>const opus_int16*</code>: The input signal as interleaved samples. This must contain <code>frame_size*channels</code> samples. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>frame_size</em>&nbsp;</td><td><code>int</code>: Number of samples per channel in the input signal. This must be an Opus frame size for the encoder's sampling rate. For example, at 48 kHz the permitted values are 120, 240, 480, 960, 1920, and 2880. Passing in a duration of less than 10 ms (480 samples at 48 kHz) will prevent the encoder from using the LPC or hybrid modes. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>data</em>&nbsp;</td><td><code>unsigned char*</code>: Output payload. This must contain storage for at least <em>max_data_bytes</em>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>max_data_bytes</em>&nbsp;</td><td><code>opus_int32</code>: Size of the allocated memory for the output payload. This may be used to impose an upper limit on the instant bitrate, but should not be used as the only bitrate control. Use <a class="el" href="group__opus__encoderctls.html#ga0bb51947e355b33d0cb358463b5101a7" title="Configures the bitrate in the encoder.">OPUS_SET_BITRATE</a> to control the bitrate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The length of the encoded packet (in bytes) on success or a negative error code (see <a class="el" href="group__opus__errorcodes.html">Error codes</a>) on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="gaff832211e572536941b9d6094f9f42ce"></a><!-- doxytag: member="opus_multistream.h::opus_multistream_encode_float" ref="gaff832211e572536941b9d6094f9f42ce" args="(OpusMSEncoder *st, const float *pcm, int frame_size, unsigned char *data, opus_int32 max_data_bytes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int opus_multistream_encode_float </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__opus__multistream.html#gae5826674d142fc873ebc1d781c507dd7">OpusMSEncoder</a> *&nbsp;</td>
          <td class="paramname"> <em>st</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&nbsp;</td>
          <td class="paramname"> <em>pcm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>frame_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="opus__types_8h.html#aa4d309d6f80b99dbabebc8f98879ab9a">opus_int32</a>&nbsp;</td>
          <td class="paramname"> <em>max_data_bytes</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Encodes a multistream Opus frame from floating point input. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>st</em>&nbsp;</td><td><code>OpusMSEncoder*</code>: Multistream encoder state. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pcm</em>&nbsp;</td><td><code>const float*</code>: The input signal as interleaved samples with a normal range of +/-1.0. Samples with a range beyond +/-1.0 are supported but will be clipped by decoders using the integer API and should only be used if it is known that the far end supports extended dynamic range. This must contain <code>frame_size*channels</code> samples. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>frame_size</em>&nbsp;</td><td><code>int</code>: Number of samples per channel in the input signal. This must be an Opus frame size for the encoder's sampling rate. For example, at 48 kHz the permitted values are 120, 240, 480, 960, 1920, and 2880. Passing in a duration of less than 10 ms (480 samples at 48 kHz) will prevent the encoder from using the LPC or hybrid modes. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>data</em>&nbsp;</td><td><code>unsigned char*</code>: Output payload. This must contain storage for at least <em>max_data_bytes</em>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>max_data_bytes</em>&nbsp;</td><td><code>opus_int32</code>: Size of the allocated memory for the output payload. This may be used to impose an upper limit on the instant bitrate, but should not be used as the only bitrate control. Use <a class="el" href="group__opus__encoderctls.html#ga0bb51947e355b33d0cb358463b5101a7" title="Configures the bitrate in the encoder.">OPUS_SET_BITRATE</a> to control the bitrate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The length of the encoded packet (in bytes) on success or a negative error code (see <a class="el" href="group__opus__errorcodes.html">Error codes</a>) on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="gaeb64c648ed8155f824ca8d9a93ccecae"></a><!-- doxytag: member="opus_multistream.h::opus_multistream_encoder_create" ref="gaeb64c648ed8155f824ca8d9a93ccecae" args="(opus_int32 Fs, int channels, int streams, int coupled_streams, const unsigned char *mapping, int application, int *error)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__opus__multistream.html#gae5826674d142fc873ebc1d781c507dd7">OpusMSEncoder</a>* opus_multistream_encoder_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="opus__types_8h.html#aa4d309d6f80b99dbabebc8f98879ab9a">opus_int32</a>&nbsp;</td>
          <td class="paramname"> <em>Fs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>channels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>streams</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>coupled_streams</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&nbsp;</td>
          <td class="paramname"> <em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>application</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>error</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocates and initializes a multistream encoder state. </p>
<p>Call <a class="el" href="group__opus__multistream.html#gaec819b8d4b38350aba6959cee7d33f94" title="Frees an OpusMSEncoder allocated by opus_multistream_encoder_create().">opus_multistream_encoder_destroy()</a> to release this object when finished. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Fs</em>&nbsp;</td><td><code>opus_int32</code>: Sampling rate of the input signal (in Hz). This must be one of 8000, 12000, 16000, 24000, or 48000. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>channels</em>&nbsp;</td><td><code>int</code>: Number of channels in the input signal. This must be at most 255. It may be greater than the number of coded channels (<code>streams + coupled_streams</code>). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>streams</em>&nbsp;</td><td><code>int</code>: The total number of streams to encode from the input. This must be no more than the number of channels. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>coupled_streams</em>&nbsp;</td><td><code>int</code>: Number of coupled (2 channel) streams to encode. This must be no larger than the total number of streams. Additionally, The total number of encoded channels (<code>streams + coupled_streams</code>) must be no more than the number of input channels. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>mapping</em>&nbsp;</td><td><code>const unsigned char[channels]</code>: Mapping from encoded channels to input channels, as described in <a class="el" href="group__opus__multistream.html">Opus Multistream API</a>. As an extra constraint, the multistream encoder does not allow encoding coupled streams for which one channel is unused since this is never a good idea. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>application</em>&nbsp;</td><td><code>int</code>: The target encoder application. This must be one of the following: </p>
<dl>
<dt><a class="el" href="group__opus__ctlvalues.html#ga07884aa018303a419d1f7acb2f3fa669" title="Best for most VoIP/videoconference applications where listening quality and intelligibility...">OPUS_APPLICATION_VOIP</a> </dt>
<dd>Process signal for improved speech intelligibility. </dd>
<dt><a class="el" href="group__opus__ctlvalues.html#ga5909f7cb35c04f1110026c6889edd345" title="Best for broadcast/high-fidelity application where the decoded audio should be as...">OPUS_APPLICATION_AUDIO</a> </dt>
<dd>Favor faithfulness to the original input. </dd>
<dt><a class="el" href="group__opus__ctlvalues.html#ga592232fb39db60c1369989c5c5d19a07" title="Only use when lowest-achievable latency is what matters most.">OPUS_APPLICATION_RESTRICTED_LOWDELAY</a> </dt>
<dd>Configure the minimum possible coding delay by disabling certain modes of operation. </dd>
</dl>
</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>error</em>&nbsp;</td><td><code>int *</code>: Returns <a class="el" href="group__opus__errorcodes.html#gaa44cf8a185e1b5cb940ef63eb4f02d21" title="No error.">OPUS_OK</a> on success, or an error code (see <a class="el" href="group__opus__errorcodes.html">Error codes</a>) on failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae14328330c548dede66c494f51e33707"></a><!-- doxytag: member="opus_multistream.h::opus_multistream_encoder_ctl" ref="gae14328330c548dede66c494f51e33707" args="(OpusMSEncoder *st, int request,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int opus_multistream_encoder_ctl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__opus__multistream.html#gae5826674d142fc873ebc1d781c507dd7">OpusMSEncoder</a> *&nbsp;</td>
          <td class="paramname"> <em>st</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Perform a CTL function on a multistream Opus encoder. </p>
<p>Generally the request and subsequent arguments are generated by a convenience macro. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>st</em>&nbsp;</td><td><code>OpusMSEncoder*</code>: Multistream encoder state. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>request</em>&nbsp;</td><td>This and all remaining parameters should be replaced by one of the convenience macros in <a class="el" href="group__opus__genericctls.html">Generic CTLs</a>, <a class="el" href="group__opus__encoderctls.html">Encoder related CTLs</a>, or <a class="el" href="group__opus__multistream__ctls.html">Multistream specific encoder and decoder CTLs</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__opus__genericctls.html" title="These macros are used with the opus_decoder_ctl and opus_encoder_ctl calls to generate...">Generic CTLs</a> </dd>
<dd>
<a class="el" href="group__opus__encoderctls.html" title="These are convenience macros for use with the opus_encode_ctl interface.">Encoder related CTLs</a> </dd>
<dd>
<a class="el" href="group__opus__multistream__ctls.html" title="These are convenience macros that are specific to the opus_multistream_encoder_ctl()...">Multistream specific encoder and decoder CTLs</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaec819b8d4b38350aba6959cee7d33f94"></a><!-- doxytag: member="opus_multistream.h::opus_multistream_encoder_destroy" ref="gaec819b8d4b38350aba6959cee7d33f94" args="(OpusMSEncoder *st)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void opus_multistream_encoder_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__opus__multistream.html#gae5826674d142fc873ebc1d781c507dd7">OpusMSEncoder</a> *&nbsp;</td>
          <td class="paramname"> <em>st</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Frees an <code>OpusMSEncoder</code> allocated by <a class="el" href="group__opus__multistream.html#gaeb64c648ed8155f824ca8d9a93ccecae" title="Allocates and initializes a multistream encoder state.">opus_multistream_encoder_create()</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>st</em>&nbsp;</td><td><code>OpusMSEncoder*</code>: Multistream encoder state to be freed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8642aa9cf16115229a655574d832293b"></a><!-- doxytag: member="opus_multistream.h::opus_multistream_encoder_get_size" ref="ga8642aa9cf16115229a655574d832293b" args="(int streams, int coupled_streams)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="opus__types_8h.html#aa4d309d6f80b99dbabebc8f98879ab9a">opus_int32</a> opus_multistream_encoder_get_size </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>streams</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>coupled_streams</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the size of an OpusMSEncoder structure. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>streams</em>&nbsp;</td><td><code>int</code>: The total number of streams to encode from the input. This must be no more than 255. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>coupled_streams</em>&nbsp;</td><td><code>int</code>: Number of coupled (2 channel) streams to encode. This must be no larger than the total number of streams. Additionally, The total number of encoded channels (<code>streams + coupled_streams</code>) must be no more than 255. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The size in bytes on success, or a negative error code (see <a class="el" href="group__opus__errorcodes.html">Error codes</a>) on error. </dd></dl>

</div>
</div>
<a class="anchor" id="gae7586aa54c322fd9599de24b5c8b8c01"></a><!-- doxytag: member="opus_multistream.h::opus_multistream_encoder_init" ref="gae7586aa54c322fd9599de24b5c8b8c01" args="(OpusMSEncoder *st, opus_int32 Fs, int channels, int streams, int coupled_streams, const unsigned char *mapping, int application)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int opus_multistream_encoder_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__opus__multistream.html#gae5826674d142fc873ebc1d781c507dd7">OpusMSEncoder</a> *&nbsp;</td>
          <td class="paramname"> <em>st</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="opus__types_8h.html#aa4d309d6f80b99dbabebc8f98879ab9a">opus_int32</a>&nbsp;</td>
          <td class="paramname"> <em>Fs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>channels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>streams</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>coupled_streams</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&nbsp;</td>
          <td class="paramname"> <em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>application</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialize a previously allocated multistream encoder state. </p>
<p>The memory pointed to by <em>st</em> must be at least the size returned by <a class="el" href="group__opus__multistream.html#ga8642aa9cf16115229a655574d832293b" title="Gets the size of an OpusMSEncoder structure.">opus_multistream_encoder_get_size()</a>. This is intended for applications which use their own allocator instead of malloc. To reset a previously initialized state, use the <a class="el" href="group__opus__genericctls.html#gadc74e4fa8bcdf9994187d52d92207337" title="Resets the codec state to be equivalent to a freshly initialized state.">OPUS_RESET_STATE</a> CTL. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__opus__multistream.html#gaeb64c648ed8155f824ca8d9a93ccecae" title="Allocates and initializes a multistream encoder state.">opus_multistream_encoder_create</a> </dd>
<dd>
<a class="el" href="group__opus__multistream.html#ga8642aa9cf16115229a655574d832293b" title="Gets the size of an OpusMSEncoder structure.">opus_multistream_encoder_get_size</a> </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>st</em>&nbsp;</td><td><code>OpusMSEncoder*</code>: Multistream encoder state to initialize. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Fs</em>&nbsp;</td><td><code>opus_int32</code>: Sampling rate of the input signal (in Hz). This must be one of 8000, 12000, 16000, 24000, or 48000. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>channels</em>&nbsp;</td><td><code>int</code>: Number of channels in the input signal. This must be at most 255. It may be greater than the number of coded channels (<code>streams + coupled_streams</code>). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>streams</em>&nbsp;</td><td><code>int</code>: The total number of streams to encode from the input. This must be no more than the number of channels. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>coupled_streams</em>&nbsp;</td><td><code>int</code>: Number of coupled (2 channel) streams to encode. This must be no larger than the total number of streams. Additionally, The total number of encoded channels (<code>streams + coupled_streams</code>) must be no more than the number of input channels. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>mapping</em>&nbsp;</td><td><code>const unsigned char[channels]</code>: Mapping from encoded channels to input channels, as described in <a class="el" href="group__opus__multistream.html">Opus Multistream API</a>. As an extra constraint, the multistream encoder does not allow encoding coupled streams for which one channel is unused since this is never a good idea. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>application</em>&nbsp;</td><td><code>int</code>: The target encoder application. This must be one of the following: </p>
<dl>
<dt><a class="el" href="group__opus__ctlvalues.html#ga07884aa018303a419d1f7acb2f3fa669" title="Best for most VoIP/videoconference applications where listening quality and intelligibility...">OPUS_APPLICATION_VOIP</a> </dt>
<dd>Process signal for improved speech intelligibility. </dd>
<dt><a class="el" href="group__opus__ctlvalues.html#ga5909f7cb35c04f1110026c6889edd345" title="Best for broadcast/high-fidelity application where the decoded audio should be as...">OPUS_APPLICATION_AUDIO</a> </dt>
<dd>Favor faithfulness to the original input. </dd>
<dt><a class="el" href="group__opus__ctlvalues.html#ga592232fb39db60c1369989c5c5d19a07" title="Only use when lowest-achievable latency is what matters most.">OPUS_APPLICATION_RESTRICTED_LOWDELAY</a> </dt>
<dd>Configure the minimum possible coding delay by disabling certain modes of operation. </dd>
</dl>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="group__opus__errorcodes.html#gaa44cf8a185e1b5cb940ef63eb4f02d21" title="No error.">OPUS_OK</a> on success, or an error code (see <a class="el" href="group__opus__errorcodes.html">Error codes</a>) on failure. </dd></dl>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<!--BEGIN GENERATE_TREEVIEW-->
    <li class="footer">$generatedby
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </li>
   </ul>
 </div>
<!--END GENERATE_TREEVIEW-->
<!--BEGIN !GENERATE_TREEVIEW-->
<hr class="footer"/>
<table width="100%"><tbody><tr><td>
For more information visit the <a href="http://opus-codec.org">Opus Website</a>.
</td><td><address class="footer"><small>
&copy;2013<br/>
$generatedby <a href="http://www.doxygen.org/index.html">
<!--<img class="footer" src="doxygen.png" alt="doxygen"/>-->doxygen
</a> 1.6.1
</small></address></tr></tbody></table>
<!--END !GENERATE_TREEVIEW-->
</body>
</html>
